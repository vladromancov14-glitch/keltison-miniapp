const express = require('express');
const { v4: uuidv4 } = require('uuid');
const db = require('../config/database');
const { verifyToken } = require('../middleware/auth');
const localAI = require('../services/localAI');
// YandexGPT configuration (using direct HTTP API instead of SDK)
const YANDEX_GPT_API_KEY = process.env.YANDEX_GPT_API_KEY;
const YANDEX_GPT_FOLDER_ID = process.env.YANDEX_GPT_FOLDER_ID;

if (YANDEX_GPT_API_KEY && YANDEX_GPT_FOLDER_ID) {
  console.log('‚úÖ YandexGPT credentials loaded successfully');
} else {
  console.log('‚ö†Ô∏è YandexGPT credentials not found');
}

const router = express.Router();

// Apply auth middleware (disabled for testing)
// router.use(verifyToken);

// Chat with AI assistant
router.post('/chat', async (req, res) => {
  try {
    const { message, session_id } = req.body;
    // Mock user for testing
    const user = req.user || {
      id: 1,
      telegram_id: 123456789,
      username: 'test_user',
      first_name: 'Test',
      last_name: 'User',
      is_pro: false
    };
    
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }
    
    // Get or create session
    let session;
    if (session_id) {
      const sessionResult = await db.query(
        'SELECT * FROM chat_sessions WHERE session_id = $1 AND user_id = $2',
        [session_id, user.id]
      );
      session = sessionResult.rows[0];
    }
    
    if (!session) {
      const newSessionId = uuidv4();
      const newSession = await db.query(
        'INSERT INTO chat_sessions (user_id, session_id, context) VALUES ($1, $2, $3) RETURNING *',
        [user.id, newSessionId, {}]
      );
      session = newSession.rows[0];
    }
    
    // Save user message
    await db.query(
      'INSERT INTO chat_messages (session_id, message, is_user) VALUES ($1, $2, $3)',
      [session.session_id, message, true]
    );
    
    // Generate AI response
    const aiResponse = await generateAIResponse(message, user, session);
    
    // Save AI response
    await db.query(
      'INSERT INTO chat_messages (session_id, message, is_user, metadata) VALUES ($1, $2, $3, $4)',
      [session.session_id, aiResponse.message, false, aiResponse.metadata || {}]
    );
    
    res.json({
      session_id: session.session_id,
      response: aiResponse.message,
      metadata: aiResponse.metadata || {},
      suggestions: aiResponse.suggestions || []
    });
    
  } catch (error) {
    console.error('Chat error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get chat history
router.get('/chat/:session_id', async (req, res) => {
  try {
    const { session_id } = req.params;
    const user = req.user;
    
    // Verify session belongs to user
    const sessionResult = await db.query(
      'SELECT * FROM chat_sessions WHERE session_id = $1 AND user_id = $2',
      [session_id, user.id]
    );
    
    if (sessionResult.rows.length === 0) {
      return res.status(404).json({ error: 'Session not found' });
    }
    
    // Get messages
    const messagesResult = await db.query(
      'SELECT * FROM chat_messages WHERE session_id = $1 ORDER BY created_at ASC',
      [session_id]
    );
    
    res.json({
      session_id,
      messages: messagesResult.rows
    });
    
  } catch (error) {
    console.error('Chat history error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get user's chat sessions
router.get('/sessions', async (req, res) => {
  try {
    const user = req.user;
    
    const result = await db.query(
      `SELECT cs.*, cm.message as last_message, cm.created_at as last_message_at
       FROM chat_sessions cs
       LEFT JOIN chat_messages cm ON cs.session_id = cm.session_id
       WHERE cs.user_id = $1
       ORDER BY cs.updated_at DESC
       LIMIT 10`,
      [user.id]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Sessions error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Generate AI response
async function generateAIResponse(message, user, session) {
  try {
    // Check if user has PRO subscription for advanced features
    const hasProAccess = await checkProAccess(user.id);
    
    // Analyze message for device/repair context
    const context = analyzeMessage(message);
    
    // Search for relevant instructions
    const relevantInstructions = await searchRelevantInstructions(context);
    
    // Try YandexGPT first, then OpenAI, then local AI
    let response;
    try {
      console.log('YandexGPT Debug:', {
        hasApiKey: !!YANDEX_GPT_API_KEY,
        hasFolderId: !!YANDEX_GPT_FOLDER_ID,
        folderId: YANDEX_GPT_FOLDER_ID,
        apiKeyLength: YANDEX_GPT_API_KEY ? YANDEX_GPT_API_KEY.length : 0
      });
      
      if (YANDEX_GPT_API_KEY && YANDEX_GPT_FOLDER_ID) {
        console.log('Using YandexGPT...');
        // Use YandexGPT API if available
        response = await generateYandexGPTResponse(message, context, relevantInstructions, hasProAccess);
      } else if (process.env.OPENAI_API_KEY) {
        console.log('Using OpenAI...');
        // Use OpenAI API as fallback
        response = await generateOpenAIResponse(message, context, relevantInstructions, hasProAccess);
      } else {
        throw new Error('No AI service available');
      }
    } catch (aiError) {
      console.log('AI services not available, using local AI:', aiError.message);
      // Use local AI as final fallback
      response = await localAI.generateResponse(message, context);
      
      // Add instructions if found
      if (relevantInstructions.length > 0) {
        response.message += '\n\nüìã –ù–∞–π–¥–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏:\n';
        relevantInstructions.slice(0, 3).forEach((instruction, index) => {
          response.message += `${index + 1}. ${instruction.brand_name} ${instruction.model_name} - ${instruction.title}\n`;
        });
        response.message += '\nüëâ [–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏]';
      }
    }
    
    // Add PRO upgrade suggestion if applicable
    if (!hasProAccess && context.needsProFeatures) {
      response.message += '\n\nüíé –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã—Ö –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–π –æ—Ñ–æ—Ä–º–∏—Ç–µ PRO-–ø–æ–¥–ø–∏—Å–∫—É!';
    }
    
    return response;
    
  } catch (error) {
    console.error('AI response generation error:', error);
    return {
      message: '–ò–∑–≤–∏–Ω–∏—Ç–µ, –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–µ—Ä–µ—Ñ–æ—Ä–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤–æ–ø—Ä–æ—Å –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–ª—É–∂–±—É –ø–æ–¥–¥–µ—Ä–∂–∫–∏.',
      metadata: { error: true }
    };
  }
}

// Generate YandexGPT response
async function generateYandexGPTResponse(message, context, instructions, hasProAccess) {
  try {
    const systemPrompt = `–¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –ø–æ —Ä–µ–º–æ–Ω—Ç—É –±—ã—Ç–æ–≤–æ–π —Ç–µ—Ö–Ω–∏–∫–∏ –∏ —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫–∏. –¢–≤–æ—è –∑–∞–¥–∞—á–∞ - –ø–æ–º–æ—á—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∏ —É—Å—Ç—Ä–∞–Ω–∏—Ç—å –ø–æ–ª–æ–º–∫–∏.

–ü—Ä–∞–≤–∏–ª–∞ —Ä–∞–±–æ—Ç—ã:
1. –í—Å–µ–≥–¥–∞ –∑–∞–¥–∞–≤–∞–π —É—Ç–æ—á–Ω—è—é—â–∏–µ –≤–æ–ø—Ä–æ—Å—ã –¥–ª—è —Ç–æ—á–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
2. –ü—Ä–µ–¥–ª–∞–≥–∞–π –ø–æ—à–∞–≥–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Ä–µ–º–æ–Ω—Ç—É
3. –£–∫–∞–∑—ã–≤–∞–π –Ω–∞ –≤–æ–∑–º–æ–∂–Ω—ã–µ —Ä–∏—Å–∫–∏ –∏ –º–µ—Ä—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
4. –ï—Å–ª–∏ —Ä–µ–º–æ–Ω—Ç —Å–ª–æ–∂–Ω—ã–π - —Ä–µ–∫–æ–º–µ–Ω–¥—É–π –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –º–∞—Å—Ç–µ—Ä—É
5. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É
6. –ò—Å–ø–æ–ª—å–∑—É–π –ø—Ä–æ—Å—Ç–æ–π, –ø–æ–Ω—è—Ç–Ω—ã–π —è–∑—ã–∫
7. –ï—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ—à—å —Ç–æ—á–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ - —á–µ—Å—Ç–Ω–æ —Å–∫–∞–∂–∏ –æ–± —ç—Ç–æ–º

–¢–∏–ø—ã —Ç–µ—Ö–Ω–∏–∫–∏: —Ç–µ–ª–µ—Ñ–æ–Ω—ã, –Ω–æ—É—Ç–±—É–∫–∏, —Å—Ç–∏—Ä–∞–ª—å–Ω—ã–µ –º–∞—à–∏–Ω—ã, —Ö–æ–ª–æ–¥–∏–ª—å–Ω–∏–∫–∏, –º–∏–∫—Ä–æ–≤–æ–ª–Ω–æ–≤–∫–∏, –ø–æ—Å—É–¥–æ–º–æ–π–∫–∏, —Ç–µ–ª–µ–≤–∏–∑–æ—Ä—ã.`;

    const userPrompt = message;
    
    // Prepare context information
    let contextInfo = '';
    if (context.device_type) {
      contextInfo += `–¢–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${context.device_type}\n`;
    }
    if (context.problem) {
      contextInfo += `–ü—Ä–æ–±–ª–µ–º–∞: ${context.problem}\n`;
    }
    if (instructions.length > 0) {
      contextInfo += `–ù–∞–π–¥–µ–Ω–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏: ${instructions.map(i => `${i.brand_name} ${i.model_name} - ${i.title}`).join(', ')}\n`;
    }

    const fullPrompt = contextInfo ? `${contextInfo}\n\n–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: ${userPrompt}` : userPrompt;

    // Make direct HTTP request to YandexGPT API
    console.log('üîç YandexGPT Request Debug:', {
      url: 'https://llm.api.cloud.yandex.net/foundationModels/v1/completion',
      apiKey: YANDEX_GPT_API_KEY.substring(0, 10) + '...',
      folderId: YANDEX_GPT_FOLDER_ID,
      modelUri: `gpt://${YANDEX_GPT_FOLDER_ID}/yandexgpt/latest`
    });

    const response = await fetch('https://llm.api.cloud.yandex.net/foundationModels/v1/completion', {
      method: 'POST',
      headers: {
        'Authorization': `Api-Key ${YANDEX_GPT_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        modelUri: `gpt://${YANDEX_GPT_FOLDER_ID}/yandexgpt/latest`,
        completionOptions: {
          temperature: 0.3,
          maxTokens: 1000
        },
        messages: [
          {
            role: 'system',
            text: systemPrompt
          },
          {
            role: 'user',
            text: fullPrompt
          }
        ]
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå YandexGPT API Error Details:', {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        body: errorText
      });
      throw new Error(`YandexGPT API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    
    if (!data.result || !data.result.alternatives || data.result.alternatives.length === 0) {
      throw new Error('No response from YandexGPT');
    }

    const aiResponse = data.result.alternatives[0].message.text;
    
    return {
      message: `ü§ñ –ú–∞—Å—Ç–µ—Ä –ö–Å–õ–¢–ò–°–û–ù (YandexGPT):\n\n${aiResponse}`,
      metadata: {
        context,
        instructions_found: instructions.length,
        has_pro_access: hasProAccess,
        yandexgpt_used: true
      },
      suggestions: [
        '–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏',
        '–ì–¥–µ –∫—É–ø–∏—Ç—å –∑–∞–ø—á–∞—Å—Ç–∏',
        '–ù–∞–π—Ç–∏ –º–∞—Å—Ç–µ—Ä–∞ –≤ –º–æ–µ–º –≥–æ—Ä–æ–¥–µ',
        '–°–≤—è–∑–∞—Ç—å—Å—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π'
      ]
    };
  } catch (error) {
    console.error('YandexGPT error:', error);
    throw error;
  }
}

// Generate OpenAI response

// Generate OpenAI response (if API key available)
async function generateOpenAIResponse(message, context, instructions, hasProAccess) {
  // This would integrate with OpenAI API
  // For now, return the existing logic
  const response = generateContextualResponse(context, instructions, hasProAccess);
  
  return {
    message: response,
    metadata: {
      context,
      instructions_found: instructions.length,
      has_pro_access: hasProAccess,
      openai_used: true
    },
    suggestions: generateSuggestions(context, instructions)
  };
}

// Analyze user message for context
function analyzeMessage(message) {
  const lowerMessage = message.toLowerCase();
  
  const context = {
    device_type: null,
    problem: null,
    brand: null,
    model: null,
    urgency: 'medium',
    needsProFeatures: false
  };
  
  // Detect device type
  const deviceKeywords = {
    phone: ['—Ç–µ–ª–µ—Ñ–æ–Ω', '—Å–º–∞—Ä—Ç—Ñ–æ–Ω', 'iphone', 'android', '–º–æ–±–∏–ª—å–Ω—ã–π'],
    laptop: ['–Ω–æ—É—Ç–±—É–∫', 'laptop', '–∫–æ–º–ø—å—é—Ç–µ—Ä', '–ø–∫', '–Ω–æ—É—Ç'],
    appliance: ['—Å—Ç–∏—Ä–∞–ª—å–Ω–∞—è', '—Ö–æ–ª–æ–¥–∏–ª—å–Ω–∏–∫', '–º–∏–∫—Ä–æ–≤–æ–ª–Ω–æ–≤–∫–∞', '–±—ã—Ç–æ–≤–∞—è —Ç–µ—Ö–Ω–∏–∫–∞', '–º–∞—à–∏–Ω–∞'],
    tv: ['—Ç–µ–ª–µ–≤–∏–∑–æ—Ä', '–º–æ–Ω–∏—Ç–æ—Ä', '—ç–∫—Ä–∞–Ω', '—Ç–≤']
  };
  
  for (const [type, keywords] of Object.entries(deviceKeywords)) {
    if (keywords.some(keyword => lowerMessage.includes(keyword))) {
      context.device_type = type;
      break;
    }
  }
  
  // Detect problems
  const problemKeywords = {
    '–Ω–µ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è': ['–Ω–µ –∑–∞—Ä—è–∂–∞–µ—Ç—Å—è', '–∑–∞—Ä—è–¥–∫–∞', '–±–∞—Ç–∞—Ä–µ—è', '–∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä'],
    '—Ä–∞–∑–±–∏—Ç —ç–∫—Ä–∞–Ω': ['—Ä–∞–∑–±–∏—Ç', '—Ç—Ä–µ—Å–Ω—É–ª', '—ç–∫—Ä–∞–Ω', '–¥–∏—Å–ø–ª–µ–π', '—Å—Ç–µ–∫–ª–æ'],
    '–Ω–µ –≤–∫–ª—é—á–∞–µ—Ç—Å—è': ['–Ω–µ –≤–∫–ª—é—á–∞–µ—Ç—Å—è', '–Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è', '–Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è'],
    '–º–µ–¥–ª–µ–Ω–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç': ['–º–µ–¥–ª–µ–Ω–Ω–æ', '—Ç–æ—Ä–º–æ–∑–∏—Ç', '–∑–∞–≤–∏—Å–∞–µ—Ç', '–ª–∞–≥–∞–µ—Ç'],
    '–ø–ª–æ—Ö–æ–π –∑–≤—É–∫': ['–∑–≤—É–∫', '–¥–∏–Ω–∞–º–∏–∫', '–º–∏–∫—Ä–æ—Ñ–æ–Ω', '–∞—É–¥–∏–æ'],
    '–ø–µ—Ä–µ–≥—Ä–µ–≤–∞–µ—Ç—Å—è': ['–ø–µ—Ä–µ–≥—Ä–µ–≤–∞–µ—Ç—Å—è', '–Ω–∞–≥—Ä–µ–≤–∞–µ—Ç—Å—è', '–≥–æ—Ä—è—á–∏–π', '—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞']
  };
  
  for (const [problem, keywords] of Object.entries(problemKeywords)) {
    if (keywords.some(keyword => lowerMessage.includes(keyword))) {
      context.problem = problem;
      break;
    }
  }
  
  // Detect urgency
  if (lowerMessage.includes('—Å—Ä–æ—á–Ω–æ') || lowerMessage.includes('–±—ã—Å—Ç—Ä–æ') || lowerMessage.includes('–ø–æ–º–æ–≥–∏—Ç–µ')) {
    context.urgency = 'high';
  }
  
  // Check if PRO features might be needed
  if (lowerMessage.includes('—Å–ª–æ–∂–Ω—ã–π') || lowerMessage.includes('–¥–µ—Ç–∞–ª—å–Ω–æ') || lowerMessage.includes('–ø–æ—à–∞–≥–æ–≤–æ')) {
    context.needsProFeatures = true;
  }
  
  return context;
}

// Search for relevant instructions
async function searchRelevantInstructions(context) {
  try {
    let query = `
      SELECT i.*, m.name as model_name, b.name as brand_name, p.name as problem_name
      FROM instructions i
      JOIN models m ON i.model_id = m.id
      JOIN brands b ON m.brand_id = b.id
      JOIN problems p ON i.problem_id = p.id
      WHERE 1=1
    `;
    let params = [];
    let paramCount = 0;
    
    // Add category filter if device type is known
    if (context.device_type) {
      const categoryMap = {
        phone: 1,
        laptop: 2,
        appliance: 3,
        tv: 4
      };
      
      if (categoryMap[context.device_type]) {
        paramCount++;
        query += ` AND m.category_id = $${paramCount}`;
        params.push(categoryMap[context.device_type]);
      }
    }
    
    // Add problem filter if problem is known
    if (context.problem) {
      paramCount++;
      query += ` AND p.name ILIKE $${paramCount}`;
      params.push(`%${context.problem}%`);
    }
    
    query += ' ORDER BY i.created_at DESC LIMIT 5';
    
    const result = await db.query(query, params);
    return result.rows;
    
  } catch (error) {
    console.error('Search instructions error:', error);
    return [];
  }
}

// Generate contextual response
function generateContextualResponse(context, instructions, hasProAccess) {
  let response = 'üß∞ –ú–∞—Å—Ç–µ—Ä –ö–Å–õ–¢–ò–°–û–ù:\n\n';
  
  if (instructions.length === 0) {
    response += '–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, —è –Ω–µ –Ω–∞—à–µ–ª —Ç–æ—á–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π –ø–æ –≤–∞—à–µ–π –ø—Ä–æ–±–ª–µ–º–µ. ';
    response += '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–∫–∞–∑–∞—Ç—å –±–æ–ª–µ–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ:\n';
    response += '‚Ä¢ –¢–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (—Ç–µ–ª–µ—Ñ–æ–Ω, –Ω–æ—É—Ç–±—É–∫, –±—ã—Ç–æ–≤–∞—è —Ç–µ—Ö–Ω–∏–∫–∞, —Ç–µ–ª–µ–≤–∏–∑–æ—Ä)\n';
    response += '‚Ä¢ –ú–∞—Ä–∫—É –∏ –º–æ–¥–µ–ª—å\n';
    response += '‚Ä¢ –ü–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã\n\n';
    response += '–ò–ª–∏ –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –ø–æ–∏—Å–∫–æ–º –ø–æ –∫–∞—Ç–∞–ª–æ–≥—É –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π!';
    return response;
  }
  
  if (instructions.length === 1) {
    const instruction = instructions[0];
    response += `–ù–∞—à–µ–ª –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –¥–ª—è ${instruction.brand_name} ${instruction.model_name}:\n\n`;
    response += `üìã ${instruction.title}\n`;
    response += `‚è±Ô∏è –í—Ä–µ–º—è: ${instruction.estimated_time || '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n`;
    response += `üîß –°–ª–æ–∂–Ω–æ—Å—Ç—å: ${getDifficultyText(instruction.difficulty)}\n`;
    
    if (instruction.cost_estimate > 0) {
      response += `üí∞ –ü—Ä–∏–º–µ—Ä–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å: ${instruction.cost_estimate} —Ä—É–±.\n`;
    }
    
    response += `\nüëâ [–û—Ç–∫—Ä—ã—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é]\n\n`;
    
    if (instruction.tools_required && instruction.tools_required.length > 0) {
      response += `–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: ${instruction.tools_required.join(', ')}\n`;
    }
    
    if (instruction.parts_required && instruction.parts_required.length > 0) {
      response += `–ó–∞–ø—á–∞—Å—Ç–∏: ${instruction.parts_required.join(', ')}\n`;
    }
  } else {
    response += `–ù–∞—à–µ–ª ${instructions.length} –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π:\n\n`;
    
    instructions.slice(0, 3).forEach((instruction, index) => {
      response += `${index + 1}. ${instruction.brand_name} ${instruction.model_name} - ${instruction.title}\n`;
      response += `   ‚è±Ô∏è ${instruction.estimated_time || '–ù–µ —É–∫–∞–∑–∞–Ω–æ'} | üîß ${getDifficultyText(instruction.difficulty)}\n`;
    });
    
    response += '\nüëâ [–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏]\n';
  }
  
  // Add safety warnings
  if (context.urgency === 'high') {
    response += '\n‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ! –ï—Å–ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ, —Ä–µ–∫–æ–º–µ–Ω–¥—É—é –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ —Å–µ—Ä–≤–∏—Å–Ω—ã–π —Ü–µ–Ω—Ç—Ä.';
  }
  
  return response;
}

// Generate suggestions
function generateSuggestions(context, instructions) {
  const suggestions = [];
  
  if (context.device_type) {
    suggestions.push(`–ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è ${getDeviceTypeText(context.device_type)}`);
  }
  
  if (context.problem) {
    suggestions.push(`–ù–∞–π—Ç–∏ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è "${context.problem}"`);
  }
  
  if (instructions.length > 0) {
    suggestions.push('–ì–¥–µ –∫—É–ø–∏—Ç—å –∑–∞–ø—á–∞—Å—Ç–∏');
    suggestions.push('–ù–∞–π—Ç–∏ –º–∞—Å—Ç–µ—Ä–∞ –≤ –º–æ–µ–º –≥–æ—Ä–æ–¥–µ');
  }
  
  suggestions.push('–°–≤—è–∑–∞—Ç—å—Å—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π');
  
  return suggestions;
}

// Helper functions
function getDifficultyText(difficulty) {
  const difficultyMap = {
    easy: '–õ–µ–≥–∫–æ',
    medium: '–°—Ä–µ–¥–Ω–µ',
    hard: '–°–ª–æ–∂–Ω–æ',
    expert: '–≠–∫—Å–ø–µ—Ä—Ç'
  };
  return difficultyMap[difficulty] || difficulty;
}

function getDeviceTypeText(deviceType) {
  const deviceMap = {
    phone: '—Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤',
    laptop: '–Ω–æ—É—Ç–±—É–∫–æ–≤',
    appliance: '–±—ã—Ç–æ–≤–æ–π —Ç–µ—Ö–Ω–∏–∫–∏',
    tv: '—Ç–µ–ª–µ–≤–∏–∑–æ—Ä–æ–≤'
  };
  return deviceMap[deviceType] || deviceType;
}

async function checkProAccess(userId) {
  try {
    const result = await db.query(
      'SELECT * FROM subscriptions WHERE user_id = $1 AND status = $2 AND expires_at > NOW()',
      [userId, 'active']
    );
    return result.rows.length > 0 && result.rows[0].plan !== 'free';
  } catch (error) {
    console.error('Check PRO access error:', error);
    return false;
  }
}

module.exports = router;
